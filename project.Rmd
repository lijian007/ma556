---
title: "MA556 project"
output: html_document
date: "2024-04-20"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## MA556 project

project

```{r }
library(MASS)
library(LaplacesDemon)
library(vroom)
library(rjags)
```

```{r }
datafile='/Users/lijianyu/Personal/documents/WPI/MA556/project/project-chromosome.dat'
con = file(datafile, "r")
lines=readLines(con)
lines=sapply(lines,function(line){
  x=unname(gsub('\\s+','\t',line))
  sub('^\\t','',x)
})
N=439
data=data.frame(id=1:N,x1=rep(NA,N),x2=rep(NA,N),x3=rep(NA,N),x4=rep(NA,N),x5=rep(NA,N),y=rep(NA,N))
for(i in 1:N){
  line=lines[i]
  fields=unlist(strsplit(line,'\t'))
  x1=fields[2] # intercept
  x2=fields[3] # control/treatment
  x3=fields[4] # age
  x4=fields[5] # sex, mail-1, female-0
  x5=fields[6] # mercury in blood
  y=fields[7] # %Cu (chromosome damage)
  data$x1[i]=as.numeric(x1)
  data$x2[i]=as.numeric(x2)
  data$x3[i]=as.numeric(x3)
  data$x4[i]=as.numeric(x4)
  # data$x5[i]=as.numeric(x5)
  # data$y[i]=as.numeric(y)
  data$x5[i]=ifelse(x5=='9999.0',NA,as.numeric(x5))
  data$y[i]=ifelse(y=='9999.0',NA,as.numeric(y))
}
data$sampling=c(rep(1,39),rep(0,439-39))
#impute x5 (mercury level)
n=39 #samples with known x5
y=data$x5[1:n]
X=as.matrix(data[1:n,c('x1','x2','x3','x4')])
X_t=t(X)
beta_hat=solve(X_t%*%X)%*%X_t%*%y
for(i in (n+1):nrow(data)){
  x=data[i,c('x1','x2','x3','x4')]
  data$x5[i]=(unlist(x)%*%beta_hat)[1,1]
}


#step1 use student t as the proposal generating density, the accepton rate is below 5%. not use it. see below for alternative ways (normal distribution)
#metropolis sampling
#use data[1:39,] 
N=439
v=as.matrix(data[1:N,c('x1','x2','x3','x4','x5')])
v_t=t(v)
y=data$sampling
beta_hat=solve(v_t%*%v)%*%v_t%*%y


#the matrix sigma
sigma=NA

for(i in 1:N){
  v_i=t(data[i,c('x1','x2','x3','x4','x5')]) #column vector
  v_it=t(v_i) #vector
  
  s=log(v_i%*%v_it)+(v_it%*%beta_hat)[1,1]-2*log(1+exp((v_it%*%beta_hat)[1,]))
  s=exp(s)
  
  if(any(is.na(sigma))){
    cat('use first sigma\n')
    sigma=s
  }else{
    sigma=sigma+s
  }
}
# sigma=round(sigma)
sigma=solve(sigma)
sigma=(sigma+t(sigma))/2. #to make it symmetrical

#target density: f(thea | I)
#candidate generating density: student t(beta_hat, v=N-4,sigma)

log_target_density=function(psi,X,y){
  #calculate target density, input psi is the column vector of covariant coefficients
  sum(sapply(1:nrow(X),function(i){
    v_i=t(X[i,]) #column vector
    v_it=t(v_i) #vector
    # y=data$sampling #known result
    z=v_it%*%t(psi)
    if(z>700)z=700
    x=(z*y[i])-log(1+exp(z))
    x
  }))
}

transition_probability=function(theta1, theta2,df,sigma,data){
  #calculate transition_probability for Metropolis
  X=data[,c('x1','x2','x3','x4','x5')]
  y=data$sampling
  tds2=log_target_density(theta2,X,y)-log(dmvt(theta2,mu=t(beta_hat),S=sigma,df=df))
  tds1=log_target_density(theta1,X,y)-log(dmvt(theta1,mu=t(beta_hat),S=sigma,df=df))
  min(1,exp(tds2-tds1))
}

#test different nu to get sample ratio (0.25,0.75)
nu=c(5,100,200,10,20,30,40,50)

for(i in 1:length(nu)){
  cat('i=',i,'nu[i]=',nu[i],'\n')
  theta=list()
  # theta1=matrix(c(1,1,1,1),nrow=1,dimnames=list(NULL,c('x1','x3','x4','x5')))
  theta1=t(beta_hat)
  M=100
  j=1
  theta[[j]]=theta1
  accepts=0
  rejects=0
  skip=0
  while(rejects+accepts<=M){
    theta2=rmvt(1,mu=t(beta_hat), S=sigma,df=nu[i])
    r=transition_probability(theta1,theta2,nu[i],sigma,data)
    skip=skip-1
    if(skip<0){
      if(runif(1,0,1)<r){
        accepts=accepts+1
        j=j+1
        theta1=theta2
        theta[[j]]=theta1
      }else{
        rejects=rejects+1
      }
    }
  }
  
  cat('acception ratio for nu=',nu[i],'is',accepts/(accepts+rejects),'\n')
}
# i= 1 nu[i]= 10 
# acception ratio for nu= 10 is 0.01980198 
# i= 2 nu[i]= 20 
# acception ratio for nu= 20 is 0.05940594 
# i= 3 nu[i]= 30 
# acception ratio for nu= 30 is 0.04950495 
# i= 4 nu[i]= 40 
# acception ratio for nu= 40 is 0.02970297 
# i= 5 nu[i]= 50 
# acception ratio for nu= 50 is 0.03960396 




#step1: use normal density to propose new moves
#metropolis sampling
#use data[1:39,] 
N=439
v=as.matrix(data[1:N,c('x1','x2','x3','x4','x5')])
v_t=t(v)
y=c(rep(1,39),rep(0,439-39))
beta_hat=solve(v_t%*%v)%*%v_t%*%y


#the matrix sigma
sigma=NA

for(i in 1:N){
  v_i=t(data[i,c('x1','x2','x3','x4','x5')]) #column vector
  v_it=t(v_i) #vector
  
  s=log(v_i%*%v_it)+(v_it%*%beta_hat)[1,1]-2*log(1+exp((v_it%*%beta_hat)[1,]))
  s=exp(s)
  
  if(any(is.na(sigma))){
    cat('use first sigma\n')
    sigma=s
  }else{
    sigma=sigma+s
  }
}
# sigma=round(sigma)
sigma=solve(sigma)
sigma=(sigma+t(sigma))/2. #to make it symmetrical

#target density: f(thea | I)
#candidate generating density: student t(beta_hat, v=N-4,sigma)

log_target_density=function(psi,X,y){
  #calculate target density, input psi is the column vector of covariant coefficients
  sum(sapply(1:nrow(X),function(i){
    v_i=t(X[i,]) #column vector
    v_it=t(v_i) #vector
    # y=data$sampling #known result
    z=v_it%*%t(psi)
    if(z>700)z=700
    x=(z*y[i])-log(1+exp(z))
    x
  }))
}

transition_probability=function(theta1, theta2,data){
  #calculate transition_probability for Metropolis
  X=data[,c('x1','x2','x3','x4','x5')]
  y=data$sampling
  tds2=log_target_density(theta2,X,y)
  tds1=log_target_density(theta1,X,y)
  min(1,exp(tds2-tds1))
}

# filepath<-"/Users/lijianyu/Personal/documents/WPI/MA556/project/theta.tsv"
filepath<-"/Users/lijianyu/Personal/documents/WPI/MA556/project/theta_large.tsv"

if(file.exists(filepath)){
  x=vroom(filepath)
  theta2=as.data.frame(x)
  accepts=110001
  rejects=88803
  M=110000

}else{
  theta=list()
  theta1=t(beta_hat)
  M=110000
  j=1
  theta[[j]]=theta1
  accepts=0
  rejects=0
  skip=0
  
  while(accepts<=M){
    if(j%%2000==0)cat('j=',j,'\n')
    theta2=t(as.matrix(mvrnorm(1,theta1,sigma)))
    r=transition_probability(theta1,theta2,data)
    skip=skip-1
    if(skip<0){
      if(runif(1,0,1)<r){
        accepts=accepts+1
        j=j+1
        theta1=theta2
        theta[[j]]=theta1
      }else{
        rejects=rejects+1
      }
    }
  }
  
  cat('acception ratio for nu=is',accepts/(accepts+rejects),'\n') # we got 0.552 here
  
  writeLines("x1\tx2\tx3\tx4\tx5", filepath)
  con=file(filepath,'a')
  for(line in theta){
    writeLines(paste(line,collapse='\t'),con)
  }
  close(con)
  
  theta2=do.call(rbind.data.frame, theta)
}



```
acception ratio is  $accepts/(accepts+rejects)$ 

```{r }
theta3=theta2[seq(1001,M,100),]

chains=as.mcmc.list(lapply(as.data.frame(theta3), mcmc))
# summary(chains)
# traceplot(chains)
# plot(chains)
mcmc_x1=as.mcmc(theta3$x1)
plot(mcmc_x1)

```
```{r }

mcmc_x2=as.mcmc(theta3$x2)
plot(mcmc_x2)

```
```{r }

mcmc_x3=as.mcmc(theta3$x3)
plot(mcmc_x3)

```
```{r }

mcmc_x4=as.mcmc(theta3$x4)
plot(mcmc_x4)

```
```{r }

mcmc_x5=as.mcmc(theta3$x5)
plot(mcmc_x5)

```
```{r }
autocorr(chains, lags = c( 1, 5, 10, 50))
autocorr.plot(chains)

```



```{r }
x=effectiveSize(as.mcmc(theta3$x1))
x
```


```{r }
x=geweke.diag(chains, frac1=0.1, frac2=0.5)
x
pnorm(x$x1$z)
pnorm(x$x2$z)

```

```{r }
batchSE(as.mcmc(theta3), batchSize=100)

```


```{r }
#step 2 and step 3
n_theta=nrow(theta3)
n=39
N=439
list2=list()

for(k in 1:n_theta){
  psi_k=t(theta3[k,]) #column vector
  sampling_rate=0
  pi_i=list()
  for(i in 1:n){
    v_i=t(data[i,c('x1','x2','x3','x4','x5')]) #column vector
    v_it=t(v_i) #vector
    t=v_it%*%psi_k
    if(t>700)t=700
    pi_i[[i]]=exp(t-log(1+exp(t))) 
    sampling_rate=sampling_rate+1/pi_i[[i]]
  }
  list2[[k]]=list(k=k,psi=psi_k,pi=pi_i, sampling_rate=sampling_rate,distance=abs(sampling_rate-N))
}

#step 3, find the best psi and the corresponding pi
min_distance=min(sapply(list2,function(x){x$distance}))
best_pi=unlist(list2[[which(sapply(list2,function(x){x$distance==min_distance}))]]$pi)
best_pi




```
```{r }
#step 4.calculate W
W=rep(NA,n)
N=439
for(i in 1:n){
  W[i]=N*1/best_pi[i]/sum(1/best_pi)
}

W

```
```{r }
#step 5.calculate n_hat
n_hat=sum(W)^2/sum(W^2)
n_hat
```
```{r }
#step 6.calculate w
w=n_hat*W/sum(W)

w

```
```{r }
#step 7.impute missing y0, y1

data_y0=data[data$sampling==1&data$x2==0,]
data_y1=data[data$sampling==1&data$x2==1,]



X_y0=as.matrix(data_y0[,c('x1','x3','x4','x5')])
X_y1=as.matrix(data_y1[,c('x1','x3','x4','x5')])
X_y0_t=t(X_y0)
X_y1_t=t(X_y1)

beta_hat_y0=solve(X_y0_t%*%X_y0)%*%X_y0_t%*%data_y0$y
beta_hat_y1=solve(X_y1_t%*%X_y1)%*%X_y1_t%*%data_y1$y
data$y0=NA
data$y1=NA
for(i in 1:n){
  x=data[i,c('x1','x3','x4','x5')]
  data$y0[i]=(unlist(x)%*%beta_hat_y0)[1,1]
  data$y1[i]=(unlist(x)%*%beta_hat_y1)[1,1]
}
data[1:n,]

```

```{r }
#step 8.calculate posterior beta0, t, deta0, deta1, ro
#starting values
df=as.matrix(data[1:n,c('x1','x2','x3','x4','x5')])
df_t=t(df)
beta0=solve(df_t%*%df)%*%df_t%*%data[1:n,'y']
t=mean(data_y1$y)/mean(data_y0$y)
sigma0=sd(data_y0$y)
sigma1=sd(data_y1$y)
n=39
model.data=list(
  y=data[1:n,c('y0','y1')],
  w=w,
  v=data[1:n,c('x1','x2','x3','x4','x5')],
  n=n,
  identity=matrix(c(1,0,0,1),nrow=2,ncol=2),
  b0=beta0
  
)
# model.params=c('t','beta0','sigma0','sigma1','rho',)
model.inits=list(t=t,beta0=beta0,sigma0=sigma0,sigma1=sigma1,rho=0.5)
iterations=11000
modelString="
  model{
    for(i in 1:n){
        dmat[2*i+1,2*i+1]=sigma0^2/w[i]
        dmat[2*i+1,2*i+2]=rho*sigma0*sigma1/w[i]
        dmat[2*i+2,2*i+1]=rho*sigma0*sigma1/w[i]
        dmat[2*i+2,2*i+2]=sigma1^2/w[i]
        mu[0]=inprod(v[i,],beta0)
        mu[1]=t+inprod(v[i,],beta0)
        y[i,]~dmnorm(mu,dmat[(2*i+1):(2*i+2),(2*i+1):(2*i+2)])
    }
    rho~dunif(0,1)
    t~dexp(0.0001)
    beta0~dmnorm(b0,identity)
    sigma0~dunif(0,1)
    sigma1~dunif(0,1)
  }

"
writeLines(modelString,con="tempmodel.txt")
jagsModel=jags.model(file="tempmodel.txt",data=model.data,inits=model.inits)


density=function(beta0,t,sigma0,sigma1,rho,w,data,n){
  #data has columns: x1, x2, x3,x4, x5,y0,y1
  #n=39
  A=sapply(1:n,function(i){
    (data[i,'y0']-data[i,c('x1','x2','x3','x4','x5')]%*%beta0)
  })
  1/(sigma0*sigma1*sqrt(1-rho^2))*exp(-1/2/(1-rho^2)*(sum()))
}

for(i in 1:M){
  
}
```
```{r}
n=39
y0 = data[1:n,'y0']
y1 = data[1:n,'y1']
tau = rep(0,11000)
beta = list()
sigma0 = rep(0,11000)
sigma1 = rep(0,11000)
rho = rep(0,11000)
sigma0[1] = var(y0);
sigma01 = sigma0[1]
sigma1[1] = var(y1);
sigma11 = sigma1[1]
mod = lm(y~x2+x3+x4+x5,data=data[1:n,])
tau[1] = coef(mod)['x2'];
tau1= tau[1]
rho[1] = cor(y0,y1);
rho1 = rho[1]
beta[[1]] = t(coef(mod));
beta1 = t(beta[[1]])

set.seed(123)


s=seq(0.01,0.99,0.001)
grid_sampler=function(lh,s){
  h=exp(lh-max(lh))/sum(exp(lh-max(lh)))
  draw=sample(s,1, prob=h)
  draw_jitter=runif(1,draw-0.0005,draw+0.0005)
  draw_jitter
}
cpd_sigma1=function(beta0,tau,sigma0,rho,w,xdata,n,s){
  #return log density for all values in s
  t=tau
  d=rep(NA,length(s))
  for(k in 1:length(s)){
    h=s[k]
    A=sapply(1:n,function(i){(xdata[i,'y0']-as.matrix(xdata[i,c('x1','x2','x3','x4','x5')])%*%beta0)/(sigma0/sqrt(w[i]))})
    Bp=sapply(1:n,function(i){(xdata[i,'y1']-(t+as.matrix(xdata[i,c('x1','x2','x3','x4','x5')])%*%beta0))/((1/h-1)/sqrt(w[i]))})
    d_1=-n*log(1/h-1)-1/(2*(1-rho**2))*(-2*rho*sum(A*Bp)+sum(Bp**2))-2*log(h)
    d[k]=d_1
    
  }
  d
}



density=function(beta0,tau,sigma0,sigma1,rho,w,xdata,n){
  #data has columns: x1, x2, x3,x4, x5,y0,y1
  #n=39
  t=tau
  A=sapply(1:n,function(i){
    (xdata[i,'y0']-as.matrix(xdata[i,c('x1','x2','x3','x4','x5')])%*%beta0)/(sigma0/sqrt(w[i]))
  })
  # print(A)
  B=sapply(1:n,function(i){
    (xdata[i,'y1']-(t+as.matrix(xdata[i,c('x1','x2','x3','x4','x5')])%*%beta0))/(sigma1/sqrt(w[i]))
  })
  # print(B)
  ev=-1/(2*(1-rho^2))*(sum(A^2))-2*rho*sum(A*B)+sum(B**2)
  # print('ev')
  # print(ev)
  # print(n)
  if(ev>100)ev=100
  # print(sigma0)
  # print(sigma1)
  # print('1-roh2')
  # print((1-rho^2))
  # print(sigma0*sigma1*sqrt(1-rho^2))
  if((sigma0*sigma1*sqrt(1-rho^2))^n<1e-100){
    return(1e-100)
  }
  # print((sigma0*sigma1*sqrt(1-rho^2))^n)
  # print((sigma0*sigma1*sqrt(1-rho^2))^n*exp(ev))
  1/(sigma0*sigma1*sqrt(1-rho^2))^n*exp(ev)
}

accepts_beta=0
rejects_beta=0

accepts_sigma0=0
rejects_sigma0=0



accepts_tau=0
rejects_tau=0

accepts_rho=0
rejects_rho=0
for(j in 2:30) {
      if(j%%100==0)cat('j=',j,'\n')
      #draw beta
      flag=T
      while(flag){
        beta2 = as.matrix(mvrnorm(n = 1, mu=beta1, Sigma = diag(5)))
        U = runif(1)
        if (U <= density(beta2,tau1,sigma01,sigma11,rho1,w,data[1:n,],n)/density(beta1,tau1,sigma01,sigma11,rho1,w,data[1:n,],n)){
          beta1 = beta2
          beta[[j]] = beta2
          flag=F
          accepts_beta=accepts_beta+1
        }else{
          rejects_beta=rejects_beta+1
        }
      }
      
      #draw sigma0
      flag=T
      while(flag){
        sigma02 =  rnorm(1,mean=sigma01,sd=0.01)
        U =runif(1)
        if (U <= density(beta1,tau1,sigma02,sigma11,rho1,w,data[1:n,],n)/density(beta1,tau1,sigma01,sigma11,rho1,w,data[1:n,],n)){
          sigma01 = sigma02
          sigma0[j] = sigma01
          flag=F
          accepts_sigma0=accepts_sigma0+1
        }else{
          rejects_sigma0=rejects_sigma0+1
        }
      }
      
      #draw sigma1 using grid method
      sigma12 =grid_sampler(cpd_sigma1(beta1,tau1,sigma01,rho1,w,data[1:n,],n,s),s)
      sigma11 = sigma12
      sigma1[j] = sigma11

      #draw tau
      flag=T
      while(flag){
        tau2 = rnorm(n = 1, mean = tau1, sd = 0.7931246)
        U = runif(1)
        if (U <= density(beta1,tau2,sigma01,sigma11,rho1,w,data[1:n,],n)/density(beta1,tau1,sigma01,sigma11,rho1,w,data[1:n,],n)){
          tau1 = tau2
          tau[j] = tau1
          flag=F
          accepts_tau=accepts_tau+1
        }else{
          rejects_tau=rejects_tau+1
        }
      }
     #draw rho
      flag=T
      while(flag){
        rho2 = rnorm(1,mean=rho1,sd=0.01)
        U = runif(1)
        if (U <= density(beta1,tau1,sigma01,sigma11,rho2,w,data[1:n,],n)/density(beta1,tau1,sigma01,sigma11,rho1,w,data[1:n,],n)){
          rho1 = rho2
          rho[j] = rho1
          flag=F
          accepts_rho=accepts_rho+1
        }else{
          rejects_rho=rejects_rho+1
        }
  
      }
}
```
## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}
plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
